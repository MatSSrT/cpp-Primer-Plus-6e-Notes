## 第 8 章 函数探幽

C++区别于C语言，提供了新特性：包括 **`内联函数、按引用传递变量、默认的参数值、函数重载（多态）以及模板函数`**。

### 1.内联函数

内联函数的编译代码与其它程序代码内联，编译器就使用相应的函数代码替换函数调用。

#### 1.1 常规函数和内联函数

**常规函数**：调用使得程序调到另一个地址（函数的地址），并在函数结束时返回。

> 将程序流程转到独立的函数。

**内联函数**：程序无需跳到另一个位置处执行代码，再跳回来。

> 用内联函数的代码来替换函数调用。

#### 1.2 内联函数的优缺点

**优点**：运行速度比常规函数快。

**缺点**：占用内存大

#### 1.3 使用内联函数的要求

- 在函数 `声明前` 加上 关键字inline
- 在函数 `定义前` 加上 关键字inline
- 一般用法：省略原型，将整个定义（函数头和所有函数代码）放在本应提供原型的地方。
- ⚠️注意点：~~内联函数不能递归~~

👉例子：square函数计算

```C++
#include<iostream>

inline double square(double x){return x*x;}

int main()
{
	using namespace std;
	double a,b;
	double c = 13.0;
	a = square(5.0);
	b = square(4.5 + 7.5);
	cout << "a = "<<a<<" , b = "<<b<<"\n"; // a =25 b = 144
	cout << "c = "<<c; //c = 13
	cout << ", c squared = "<<square(c++)<<"\n"; // c = 14*14=169
	cout << "Now c = "<<c<<"\n"; //c=14
	return 0;
}
```

✅内联函数和常规函数一样，都是按值来传递参数。

> 在将值传递给函数square之前，程序自动把传入值强制转换为double类型。

#### 1.4 内联和宏

inline是C++新增特性。

> 在C语言中使用`预处理器#define`来提供宏。————> 内联代码的原始实现。
>
> ```c
> #define SQUARE(x) x*x
> ```
>
> 此时不是通过传递参数实现，而是通过文本替换来实现。

**宏的缺点**：~~不能按值传递~~。
### 2. 引用变量

**引用**：已定义变量的别名。

**主要用途**：用作 `函数的形参`。通过引用变量用作参数，函数将使用原始数据，而不是使用副本。

#### 2.1 创建引用变量

C和C++中使用 `地址符（&）` 来指示变量的地址。用来声明引用。

```c++
int rats;
int & rodents = rats; // &不是地址运算符，是类型标识符的一部分。
```

引用 <u>必须在声明引用时将其初始化</u>，而不是类似指针，先声明，再赋值。

> 引用更接近 const指针，<u>*必须在创建时进行初始化*</u>，变量关联后，就无法更改。

#### 2.2 引用用作函数参数

**引用传递**：当引用被用作函数参数时，使得函数中的变量名成为调用程序中的变量的别名。

> 允许被调用的函数能够`访问调用函数`中的变量。

**按值传递**：被调用函数使用调用程序的值的**拷贝**。

> C语言中改用按指针传递的方式避开按值传递的限制。

使用和访问原始数据的方法：按 **`引用传递`** 和 **`传递指针`**。

当左值引用参数是 const时，会生成临时变量的两种情况：

> 实参的类型正确，但不是左值。
>
> 实参的类型不正确，但可转换为正确的类型。

**尽可能使用const**

>- 使用const可以避免无意中修改数据的编程错误
>
>- 使用const使函数能够处理const和非const实参 否则只能接受非const数据
>
>- 使用const引用使函数能够正确生成并使用临时变量(如果实参和应用参数不匹配，c++将生成临时变量)

C++11 引入 **`右值引用`**，使用 `&&` 来声明。

### 2.3 结构引用

引用适合 **结构和类**（用户自定义类型，非基本的内置类型）。

使用 `结构引用参数`的方式 与`基本变量引用` 相同，只需在声明结构参数时使用 `引用运算符&` 即可。



