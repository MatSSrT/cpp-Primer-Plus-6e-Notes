## 第 8 章 函数探幽

### 👉【[复习题](./复习题.md)】【[编程练习题](./编程题.md)】

C++区别于C语言，提供了新特性：包括 **`内联函数、按引用传递变量、默认的参数值、函数重载（多态）以及模板函数`**。

### 1.内联函数

编译过程的目标是`可执行程序（由一组机器语言指令组成）`。运行程序时，操作系统将指令载入到计算机内存中，则每条指令都有其`特定的内存地址`。

内联函数的编译代码与其它程序代码内联，编译器就使用相应的函数代码替换函数调用。

#### 1.1 常规函数和内联函数

**常规函数**：调用使得程序调到另一个地址（函数的地址），并在函数结束时返回。

> 将程序流程转到独立的函数。

**内联函数**：程序无需跳到另一个位置处执行代码，再跳回来。

> 用内联函数的代码来替换函数调用。

#### 1.2 内联函数的优缺点

**优点**：运行速度比常规函数快。

**缺点**：占用内存大

#### 1.3 使用内联函数的要求

- 在函数 `声明前` 加上 关键字inline
- 在函数 `定义前` 加上 关键字inline
- 一般用法：省略原型，将整个定义（函数头和所有函数代码）放在本应提供原型的地方。
- ⚠️注意点：~~内联函数不能递归~~

👉例子：square函数计算

```C++
#include<iostream>

inline double square(double x){return x*x;}

int main()
{
	using namespace std;
	double a,b;
	double c = 13.0;
	a = square(5.0);
	b = square(4.5 + 7.5);
	cout << "a = "<<a<<" , b = "<<b<<"\n"; // a =25 b = 144
	cout << "c = "<<c; //c = 13
	cout << ", c squared = "<<square(c++)<<"\n"; // c = 14*14=169
	cout << "Now c = "<<c<<"\n"; //c=14
	return 0;
}
```

✅内联函数和常规函数一样，都是按值来传递参数。

> 在将值传递给函数square之前，程序自动把传入值强制转换为double类型。

#### 1.4 内联和宏

inline是C++新增特性。

> 在C语言中使用`预处理器#define`来提供宏。————> 内联代码的原始实现。
>
> ```c
> #define SQUARE(x) x*x
> ```
>
> 此时不是通过传递参数实现，而是通过文本替换来实现。

**宏的缺点**：~~不能按值传递~~。
### 2. 引用变量

**引用**：已定义变量的别名。

**主要用途**：用作 `函数的形参`。通过引用变量用作参数，函数将使用原始数据，而不是使用副本。

#### 2.1 创建引用变量

C和C++中使用 `地址符（&）` 来指示变量的地址。用来声明引用。

```c++
int rats;
int & rodents = rats; // &不是地址运算符，是类型标识符的一部分。
```

引用 <u>必须在声明引用时将其初始化</u>，而不是类似指针，先声明，再赋值。

> 引用更接近 const指针，<u>*必须在创建时进行初始化*</u>，变量关联后，就无法更改。

#### 2.2 引用用作函数参数

**引用传递**：当引用被用作函数参数时，使得函数中的变量名成为调用程序中的变量的别名。

> 允许被调用的函数能够`访问调用函数`中的变量。

**按值传递**：被调用函数使用调用程序的值的**拷贝**。

> C语言中改用按指针传递的方式避开按值传递的限制。

使用和访问原始数据的方法：按 **`引用传递`** 和 **`传递指针`**。

当左值引用参数是 const时，会生成临时变量的两种情况：

> 实参的类型正确，但不是左值。
>
> 实参的类型不正确，但可转换为正确的类型。

**尽可能使用const**

>- 使用const可以避免无意中修改数据的编程错误
>
>- 使用const使函数能够处理const和非const实参 否则只能接受非const数据
>
>- 使用const引用使函数能够正确生成并使用临时变量(如果实参和应用参数不匹配，c++将生成临时变量)

C++11 引入 **`右值引用`**，可指向右值，使用 `&&` 来声明。

#### 2.3 结构引用

引用适合 **结构和类**（用户自定义类型，非基本的内置类型）。

使用 `结构引用参数`的方式 与`基本变量引用` 相同，只需在声明结构参数时使用 `引用运算符&` 即可。

#### 2.4 返回引用时的注意事项
避免返回函数终止时不再存在的内存单元引用。原因：函数运行完毕后将不存在。

~~杜绝使用临时变量的引用~~
```cpp
const free_throws & clone2(free_throws &ft)
{
	free_throws newguy; // 
	newguy = &ft; // 拷贝
	return newguy; //返回拷贝引用
}
```
> 解决方法：
> 
> 1.返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，返回的引用也随之指向所使用的数据。
>
> 2.使用new来分配新的存储空间，使得返回指向该内存空间的指针。👉**小缺点**：会忘记使用 `delete` 来`释放内存`。

改进后：
```C++
const free_throws & clone(free_throws &ft)
{
	free_throws *pt; //使用指针指向结构，所以*pt可直接代表 free_throws这个结构
	*pt = ft; //拷贝信息
	return *pt; //返回
}
```
#### 2.5 对象、继承和引用
**继承**：将语言的特性从`一个类` *传递* 给`另一个类`。

**继承的特征**：派生来继承了基类的方法，基类引用可以指向派生类对象，而`无需进行强制类型转换`。
> `ostream`是基类
>
> `ofstream`是派生类

#### 2.7 何时使用引用参数

***使用引用参数的两个主要原因***
- 程序员能修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，提高程序的运行速度。（当数据对象（结构和类对象）较大时很重要）

***对于 `使用传递的值` 而 `不作修改` 的函数***
- 数据对象`很小`，如`内置数据类型或小型结构`，**`按值传递`**；
- 数据对象是`数组`，则使用`指针`，因为这是唯一的选择，并将 **`指针声明为指向 const 的指针`**；
- 数据对象是`较大的结构`，则使用 `const 指针`或 `const 引用`，可以 ***节省复制结构所需的时间和空间***；
- 数据对象是`类对象`，则使用 `const 引用`。传递类对象参数的标准方式是 **`按引用传递`**。

***对于`修改调用函数中数据`的函数***

- 数据对象是`内置数据类型`，则使用`指针`；

- 数据对象是`数组`，则`只能`使用`指针`；

- 数据对象是`结构`，则使用`引用或指针`；

- 数据对象是`类对象`，则使用`引用`。


### 默认参数
**定义**：指当函数调用中省略了实参时自动使用的一个值。

设置默认值的方法：通过函数原型将值赋给原型中的参数。例left() 原型：
```cpp
char *left(const char *str,int n = 1);
```

对于`带参数列表`的函数，必须`从右向左`添加默认值（要为某个参数设置默认值，必须为其右边的所有参数提供默认值）。
```cpp
int harpo(int n,int m = 4 , int j = 5); //VALID
int chico(int n ,int m = 6,int j); // INVALID
```

实参按 `从左向右` 的顺序依次被赋给相应的形参，而~~不能跳过任何参数~~。
```cpp
beeps = harpo(3, ,8); // 不允许
```

**👉 默认参数的好处**：*减少要定义的析构函数、方法以及方法重载的数量**。

⚠️注意：只有原型指定了默认值，函数定义与没有默认参数时完全相同。

[代码例子](./07.默认参数的例子.cpp)





